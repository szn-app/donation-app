#!/bin/bash
set -e

rust_script#setup#task@monorepo() {
    # Find all .script.rs files recursively from current directory
    local rust_script_files=()
    mapfile -t rust_script_files < <(find . -type f -name "*.script.rs")

    # Make each found file executable
    for script in "${rust_script_files[@]}"; do
        chmod +x "$script"
    done

    echo "All rust scripts are now executable"
}

git_submodule#setup@monorepo() {
    clone_with_submodules() { 
        git clone --recursive https://github.com/szn-app/donation-app
    }

    onetime_intialization() {
        git submodule add https://github.com/szn-app/fork-kratos-selfservice-ui-node.git service/auth-ui/kratos-selfservice-ui-node
        git submodule add https://github.com/szn-app/ai-generated dependency/ai-generated
    }

    example_remove() { 
        git submodule deinit -f service/auth-ui/kratos-selfservice-ui-node
        git rm --cached service/auth-ui/kratos-selfservice-ui-node
        rm -r .git/modules/kratos-selfservice-ui-node
        # [manual] remove section from .git/config
    }

    git submodule init && git submodule update
}

docker_github_container_registry#setup@monorepo() {
    CR_PAT='token'
    echo $CR_PAT | docker login ghcr.io -u 'username' --password-stdin # using PAT token    
}

generate_initial_release_please_config#setup@monorepo() {
    pnpm install release-please -g

    # using `release-please-config.json` file to bootstrap release-please 
    release-please bootstrap --token=$GITHUB_TOKEN --repo-url=szn-app/donation-app --dry-run

    # for debug development: 
    release-please release-pr --token=$GITHUB_TOKEN --repo-url=szn-app/donation-app --dry-run
    release-please github-release --token=$GITHUB_TOKEN --repo-url=szn-app/donation-app
}


# https://code.visualstudio.com/docs/editor/tasks
add_vscode_tasks#setup#task@monorepo() {
    mkdir -p .vscode
    
    for task in $(filter_functions_by_args.util '#task'); do
        echo "Adding task: $task"

        # Check if task already exists
        if ! grep -qw "\"label\":[[:space:]]*\"$task\"" .vscode/tasks.json; then
            # Use jq to properly add task to JSON structure
            local t=$(mktemp)

            # Remove comments from extended json5 and add task
            sed '/^[[:space:]]*\/\//d' .vscode/tasks.json | \
            jq --arg task "$task" '.tasks += [{
                "label": $task,
                "type": "shell",
                "command": "bash",
                "args": ["-c", "source ${workspaceFolder}/script.sh && " + $task],
                "presentation": {
                    "reveal": "always",
                    "panel": "dedicated"
                },
                "group": "none",
                "options": {
                    "cwd": "${workspaceFolder}/", 
                      "statusbar": {
                      "label" : "$(run) '$task'",
                    }
                },
                "dependsOrder": "parallel",
                "dependsOn": [],
                "problemMatcher": []
            }]' > "$t"
            
            # Add autogenerated comment
            echo '// File is autogenerated by scanning all script and adding functions which has "#task" to their name' | cat - "$t" > temp && mv temp "$t"
            
            mv "$t" .vscode/tasks.json
            echo "Task '$task' added to tasks.json"
        else
            echo "Task '$task' already exists, skipping"
        fi
    done

    # Remove tasks that do not have an equivalent task entry
    {
        local current_tasks=$(mktemp)
        sed '/^[[:space:]]*\/\//d' .vscode/tasks.json | \
        jq '.tasks[] | .label' > "$current_tasks"

        for task in $(cat "$current_tasks"); do
            task=$(echo "$task" | tr -d '"')
            # Skip tasks that don't have '#task' in their name
            if [[ "$task" != *"#task"* ]]; then
                echo "Skipping task '$task' as it doesn't contain '#task' thus wasn't autogenerated"
                continue
            fi

            if ! filter_functions_by_args.util '#task' | grep -qw "$task"; then
                sed '/^[[:space:]]*\/\//d' .vscode/tasks.json | \
                jq --arg task "$task" 'del(.tasks[] | select(.label == $task))' > .vscode/tasks.json.tmp && mv .vscode/tasks.json.tmp .vscode/tasks.json
            fi
        done

        rm "$current_tasks"
    }

}

add_vscode_workspaces#setup#task@monorepo() {
    local manifest_file=".release-please-manifest.json"
    if [[ -f "$manifest_file" ]]; then
        mapfile -t workspacePath < <(jq -r 'keys[]' "$manifest_file" | grep -v '^.$')
    else
        echo "File '$manifest_file' not found."
    fi

    local workspace_file="workspace.code-workspace"
    # Ensure file exists with default structure
    cat <<EOF > "$workspace_file"
{
    "folders": [],
    "settings": {
        "workbench.colorCustomizations": {
            "activityBar.background": "#5A0A38",
            "titleBar.activeBackground": "#7E0E4E",
            "titleBar.activeForeground": "#FFFCFD"
        }
    }
}
EOF

    # Add each key as a new folder path
    local tmp=$(mktemp)
    cp "$workspace_file" "$tmp"
    
    for key in "${workspacePath[@]}"; do
        jq --arg path "$key" '.folders += [{"path": $path}]' "$tmp" > "$tmp.new"
        mv "$tmp.new" "$tmp"
    done
    
    echo '// autogenerated by adding workspaces paths from release-please configuration' | cat - "$tmp" > temp && mv temp "$workspace_file"
}

config#aggregate_setup#task@monorepo() {
    execute.util '#setup' '#task' '@monorepo'
}


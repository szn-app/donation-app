#!/bin/bash
set -e  

# call function in this script file from commandline argument
call_function() {
    fn_name="$1"
    if [[ $# -lt 1 ]]; then
        # This case can be used for executing $`source ./script.sh` to load functions to current shell session.
        echo "use 'source ./script.sh' to load functions to current shell session"
    elif ! declare -f "$fn_name" || ! [[ $(type -t "$fn_name") ]]; then
        echo "Error: function '$fn_name' not declared."
        exit 1
    else
        # redirect call to function name provided
        shift
        "$fn_name" "$@"
    fi
}

filter_functions_by_args.util() {
    local keywords=("$@")
    local matches=()
    for fn in $(declare -F | awk '{print $3}'); do
        declare -i matchAll=1
        for kw in "${keywords[@]}"; do
            if [[ "$fn" != *"$kw"* ]]; then
                matchAll=0
                break
            fi
        done
        if [[ $matchAll -eq 1 ]]; then
            matches+=("$fn")
        fi
    done
    echo "${matches[@]}"
}

execute.util() {         
    # execute each function directly from filter_functions_by_args.util output
    for func in $(filter_functions_by_args.util "$@"); do
        echo "Executing $func..."
        $func
        local exit_code=$?
        if [[ $exit_code -ne 0 ]]; then
            echo "Error: $func exited with code $exit_code"
        fi
    done
}

filter_script_files_by_directory.util() {
    local directory="$1"
    local script_files=()
    for file in $(find "$directory" -type f -name "*.sh"); do
        script_files+=("$file")
    done
    echo "${script_files[@]}"
}

filter_script_files_by_args.util() {
    local root_directory="$1"
    shift
    local keywords=("$@")
    local script_files=()
    
    # If no keywords provided, return all script files
    if [[ ${#keywords[@]} -eq 0 ]]; then
        echo $(filter_script_files_by_directory.util "$root_directory")
        return
    fi
    
    for file in $(filter_script_files_by_directory.util "$root_directory"); do
        for kw in "${keywords[@]}"; do
            if [[ "$file" == *"$kw"* ]]; then
                script_files+=("$file")
                break
            fi
        done
    done
    
    echo "${script_files[@]}"
}

load_scripts_recursive.util() {
    local root_directory="$1"  # Get directory from argument
    shift  # Remove first argument (directory) to pass remaining args as keywords
    local keywords=("$@")

    # Validate input
    if [[ -z "$root_directory" ]]; then
        echo "Usage: $0 <script_directory> [keywords...]"
        return 1
    elif [[ ! -d "$root_directory" ]]; then
        echo "Error: '$root_directory' is not a valid directory."
        return 1
    fi

    # Find and source all matching .sh scripts recursively
    # filter_script_files_by_args.util already handles the case when no keywords are provided
    for script in $(filter_script_files_by_args.util "$root_directory" "${keywords[@]}"); do
        echo "Sourcing $script..."
        source "$script"
    done
}

# https://code.visualstudio.com/docs/editor/tasks
add_vscode_tasks#setup#task@monorepo() {
    mkdir -p .vscode
    
    for task in $(filter_functions_by_args.util '#task'); do
        echo "Adding task: $task"

        # Check if task already exists
        if ! grep -qw "\"label\":[[:space:]]*\"$task\"" .vscode/tasks.json; then
            # Use jq to properly add task to JSON structure
            local t=$(mktemp)

            # Remove comments from extended json5 and add task
            sed '/^[[:space:]]*\/\//d' .vscode/tasks.json | \
            jq --arg task "$task" '.tasks += [{
                "label": $task,
                "type": "shell",
                "command": "bash",
                "args": ["-c", "source ${workspaceFolder}/script.sh && " + $task],
                "presentation": {
                    "reveal": "always",
                    "panel": "new"
                },
                "group": "none",
                "options": {
                    "cwd": "${workspaceFolder}/", 
                      "statusbar": {
                      "label" : "$(run) '$task'",
                    }
                },
                "dependsOrder": "parallel",
                "dependsOn": [],
                "problemMatcher": []
            }]' > "$t"
            
            # Add autogenerated comment
            echo '// File is autogenerated by scanning all script and adding functions which has "#task" to their name' | cat - "$t" > temp && mv temp "$t"
            
            mv "$t" .vscode/tasks.json
            echo "Task '$task' added to tasks.json"
        else
            echo "Task '$task' already exists, skipping"
        fi
    done

    # Remove tasks that do not have an equivalent task entry
    {
        local current_tasks=$(mktemp)
        sed '/^[[:space:]]*\/\//d' .vscode/tasks.json | \
        jq '.tasks[] | .label' > "$current_tasks"

        for task in $(cat "$current_tasks"); do
            task=$(echo "$task" | tr -d '"')
            if ! filter_functions_by_args.util '#task' | grep -qw "$task"; then
                sed '/^[[:space:]]*\/\//d' .vscode/tasks.json | \
                jq --arg task "$task" 'del(.tasks[] | select(.label == $task))' > .vscode/tasks.json.tmp && mv .vscode/tasks.json.tmp .vscode/tasks.json
            fi
        done

        rm "$current_tasks"
    }

}

add_vscode_workspaces#setup#task@monorepo() {
    local manifest_file=".release-please-manifest.json"
    if [[ -f "$manifest_file" ]]; then
        mapfile -t workspacePath < <(jq -r 'keys[]' "$manifest_file" | grep -v '^.$')
    else
        echo "File '$manifest_file' not found."
    fi

    local workspace_file="workspace.code-workspace"
    # Ensure file exists with default structure
    cat <<EOF > "$workspace_file"
{
    "folders": [],
    "settings": {
        "workbench.colorCustomizations": {
            "activityBar.background": "#5A0A38",
            "titleBar.activeBackground": "#7E0E4E",
            "titleBar.activeForeground": "#FFFCFD"
        }
    }
}
EOF

    # Add each key as a new folder path
    local tmp=$(mktemp)
    cp "$workspace_file" "$tmp"
    
    for key in "${workspacePath[@]}"; do
        jq --arg path "$key" '.folders += [{"path": $path}]' "$tmp" > "$tmp.new"
        mv "$tmp.new" "$tmp"
    done
    
    echo '// autogenerated by adding workspaces paths from release-please configuration' | cat - "$tmp" > temp && mv temp "$workspace_file"
}

config#aggregate_setup#task@monorepo() {
    execute.util '#setup' '#task' '@monorepo'
}

#!/bin/bash
set -e  


filter_functions_by_args.util() {
    local keywords=("$@")
    local matches=()
    for fn in $(declare -F | awk '{print $3}'); do
        for kw in "${keywords[@]}"; do
            if [[ "$fn" == *"$kw"* ]]; then
                matches+=("$fn")
                break
            fi
        done
    done
    echo "${matches[@]}"
}

execute.util() {         
    # execute.util each function directly from filter_functions_by_args.util output
    for func in $(filter_functions_by_args.util "$@"); do
        echo "Executing $func..."
        $func
        local exit_code=$?
        if [[ $exit_code -ne 0 ]]; then
            echo "Error: $func exited with code $exit_code"
        fi
    done
}

filter_script_files_by_directory.util() {
    local directory="$1"
    local script_files=()
    for file in $(find "$directory" -type f -name "*.sh"); do
        script_files+=("$file")
    done
    echo "${script_files[@]}"
}

filter_script_files_by_args.util() {
    local root_directory="$1"
    shift
    local keywords=("$@")
    local script_files=()
    
    # If no keywords provided, return all script files
    if [[ ${#keywords[@]} -eq 0 ]]; then
        echo $(filter_script_files_by_directory.util "$root_directory")
        return
    fi
    
    for file in $(filter_script_files_by_directory.util "$root_directory"); do
        for kw in "${keywords[@]}"; do
            if [[ "$file" == *"$kw"* ]]; then
                script_files+=("$file")
                break
            fi
        done
    done
    
    echo "${script_files[@]}"
}

load_scripts_recursive.util() {
    local root_directory="$1"  # Get directory from argument
    shift  # Remove first argument (directory) to pass remaining args as keywords
    local keywords=("$@")

    # Validate input
    if [[ -z "$root_directory" ]]; then
        echo "Usage: $0 <script_directory> [keywords...]"
        return 1
    elif [[ ! -d "$root_directory" ]]; then
        echo "Error: '$root_directory' is not a valid directory."
        return 1
    fi

    # Find and source all matching .sh scripts recursively
    # filter_script_files_by_args.util already handles the case when no keywords are provided
    for script in $(filter_script_files_by_args.util "$root_directory" "${keywords[@]}"); do
        echo "Sourcing $script..."
        source "$script"
    done
}

# https://code.visualstudio.com/docs/editor/tasks
add_vscode_tasks#bootstrap#task@monorepo() {
    mkdir -p .vscode
    
    for task in $(filter_functions_by_args.util '#task'); do
        echo "Adding task: $task"

        # Check if task already exists
        if ! grep -qw "\"label\":[[:space:]]*\"$task\"" .vscode/tasks.json; then
            # Use jq to properly add task to JSON structure
            local t=$(mktemp)

            # Remove comments from extended json5 and add task
            sed '/^[[:space:]]*\/\//d' .vscode/tasks.json | \
            jq --arg task "$task" '.tasks += [{
                "label": $task,
                "type": "shell",
                "command": "bash",
                "args": ["-c", "source ${workspaceFolder}/script.sh && " + $task],
                "presentation": {
                    "reveal": "always",
                    "panel": "new"
                },
                "group": "none",
                "options": {
                    "cwd": "${workspaceFolder}/", 
                      "statusbar": {
                      "label" : "$(run) '$task'",
                    }
                },
                "dependsOrder": "parallel",
                "dependsOn": [],
                "problemMatcher": []
            }]' > "$t"
            
            # Add autogenerated comment
            echo '// File is autogenerated by scanning all script and adding functions which has "#task" to their name' | cat - "$t" > temp && mv temp "$t"
            
            mv "$t" .vscode/tasks.json
            echo "Task '$task' added to tasks.json"
        else
            echo "Task '$task' already exists, skipping"
        fi
    done

    # Remove tasks that do not have an equivalent task entry
    {
        local current_tasks=$(mktemp)
        sed '/^[[:space:]]*\/\//d' .vscode/tasks.json | \
        jq '.tasks[] | .label' > "$current_tasks"

        for task in $(cat "$current_tasks"); do
            task=$(echo "$task" | tr -d '"')
            if ! filter_functions_by_args.util '#task' | grep -qw "$task"; then
                sed '/^[[:space:]]*\/\//d' .vscode/tasks.json | \
                jq --arg task "$task" 'del(.tasks[] | select(.label == $task))' > .vscode/tasks.json.tmp && mv .vscode/tasks.json.tmp .vscode/tasks.json
            fi
        done

        rm "$current_tasks"
    }

}